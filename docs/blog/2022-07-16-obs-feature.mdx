---
slug: obs-x-feature-update
title: Observation-x-feature support has arrived
author: Mark Keller
author_title: Gehlenborg Lab
author_url: http://gehlenborglab.org/team/members/mark-keller/
tags: [fom]
---
import MatchingDiagramTabs from '../src/pages/_MatchingDiagramTabs';

Since the start of the Vitessce project in late 2018, our team has been focused on addressing the challenges of interactive web-based visualization of **multi-modal** and **spatial** single-cell datasets.

<!--truncate-->

However, this problem is quite large in scope (as can be understood from [our over 500 GitHub issues](https://github.com/vitessce/vitessce/issues), most of them proposals for new features), and our development team has had to prioritize certain features over others.
This large scope, coupled with the small set of modalities profiled by early single-cell experiments performed by the HuBMAP Consortium (because Vitessce is embedded in the HuBMAP data portal), meant that we initially developed many features for scRNA-seq and bioimaging datasets.
Early on, we also discovered a gap in web-based tools for dynamic rendering of bioimaging data on the client side, so our team took a detour to develop the [Viv](https://doi.org/10.1038/s41592-022-01482-7) library.

While it has always been our goal to support single-cell modalities beyond transcriptomics and imaging (e.g., scATAC-seq, SNARE-seq, CITE-seq) and we have implemented some features towards this end (e.g., for visualizing cluster-level chromatin accessibility profiles), we did not prioritize these modalities.
As we focused on developing features for scRNA-seq visualization, in many places our code was written with the cell-by-gene expression matrix in mind.
For instance, when I went back to re-purpose our expression heatmap view for visualizing cell-by-peak matrices from scATAC-seq experiments, I realized I had copy-and-pasted hundreds of lines of code followed by find-and-replace to change `gene` to `peak`.
Likewise, we have been re-purposing our cell-x-gene functionality for cell-x-antigen data generated by CODEX experiments by adding function parameters that override default strings like `'gene'` rendered in plot titles and axis labels. (A similar problem arises for SLIDE-seq data which captures `bead`-level observations rather than `cell`-level ones.)
In general, a multi-modal dataset may contain gene expression _and_ antigen quantifications for the same cells, at which point this override approach fails.

Meanwhile, the HuBMAP Consortium has moved into its second phase, adding new labs and contributors, and generating many multi-modal datasets using technologies like SNARE-seq.
In parallel, the wider single-cell data analysis community has developed and adopted formats such as [AnnData](https://anndata.readthedocs.io/en/latest/) which easily generalize to non-transcriptomics single-modality experiments using the concept of an annotated **observation-x-feature** matrix (analogous to the more specific cell-x-gene from transcriptomics experiments).
Emerging formats such as [MuData](https://mudata.readthedocs.io/en/latest/) and [SOMA](https://github.com/single-cell-data/SOMA) aim to further generalize to the multi-modal case via container data structures that hold **multiple** observation-x-feature matrices.

Our team has had many discussions about updating our visualizations ("view types"), data representations ("file types"), and configuration APIs to support any dataset containing one or more observation-x-feature matrices.
While we want Vitessce to be general enough to facilitate many use cases, we recognize the danger of going overboard with abstractions (e.g., preventing users from easily updating Vitessce configurations).

## Observation-x-feature generalizations

In the latest minor version `1.3.0` of the `vitessce` JavaScript package, we have made several changes to support datasets containing observation-x-feature matrices.

### Coordination types and entity types

[Coordination type](/docs/coordination-types/) names have been updated to use `obs` and `feature` (rather than `cell` and `gene`, respectively).

We introduce the coordination types `obsType`, `featureType`, and `featureValueType` to enable **entity types** to be specified. For example, if we performed an scATAC-seq experiment and want to visualize the cell-x-peak matrix in the heatmap, then the following coordination values should be configured (via the coordination space) for our heatmap view:

```js
obsType: 'cell',
featureType: 'peak',
featureValueType: 'count'
```

This way, we can render more accurate strings like `'100 cells x 200 peaks'` in the interface (as opposed to `'100 observations x 200 features'`).
Views may also leverage specific `featureType` values like `'gene'` to know when to offer analysis features such as differential gene expression testing (which alternatively may be hidden from the user when `featureType === 'peak'`).


### Data types

[Data types](/docs/data-types-file-types/) no longer assume observation types like `cell`.

Instead, to facilitate re-use across observation types, we have split up each of the former data types into multiple more minimal data types.
For example, the former `cells` data type would now be represented using the following set of minimal data types: `obsLocations` (x-y coordinate per observation), `obsEmbedding` (dim1-dim2 coordinate per observation per embedding type), `obsSegmentations` (polygon vertices and centroid per observation).
Simplified data types also make it easier to implement new file types (including via plugins).

The former `raster` data type has been split into two new data types, `image` and `obsSegmentations`, to better reflect semantics (as opposed to exposing the implementation difference between bitmask and polygon segmentations). (Internally, the fact that an `obsSegmentations` file type may return either polygons or bitmasks is handled by returning an `obsSegmentationsType` from the data loader class.)

For the full list of data types, please visit the updated [Data Types and File Types](/docs/data-types-file-types/) page or the new [File type implementation](/docs/dev-add-loader/) page.

### Dataset definitions

Dataset definitions (in the view configuration) are no longer limited to one file per data type.

Each `dataset` may now contain multiple file definitions corresponding to the same data type.

### Mapping between files and views

File lookup from within a view now takes into account `(dataset, dataType, viewCoordinationValues)`.


The `viewCoordinationValues` tuple element refers to the coordination values that a particular view takes on at a given point in time.
This is required to disambiguate between files now that each dataset may contain multiple files per data type.

The diagram below shows how the matching between views and files would be performed for a configuration containing one dataset and three views.
<!-- Diagram -->
<MatchingDiagramTabs />

### File definitions

File definitions no longer require the `type` ("data type") property.

Instead, we now store a mapping from `fileType`s to data types internally and do the lookup automatically.

### Joint file types

Joint file types can now be defined via functions which expand one file definition into an array of file definitions.

For instance, despite removing the `cells` _data type_, the former `cells.json` _file type_ can be re-implemented via a convenience file type which expands one `cells.json` file definition into multiple file definitions corresponding to the new data types `obsEmbedding`, `obsSegmentations`, etc.
For more information, see [Joint File Types](/docs/data-types-file-types/#joint-file-types).

### View config schema

The changes described here are reflected in the [latest view config schema version](/docs/view-config-json/#version).

We now include a tool in our documentation to compare view config schema versions by diff-ing the JSON objects.

### Python and R support

The changes described here are not yet reflected in the Vitessce Python and R packages. 

We will now work to update the code for generating view configs in Python and R and will release new versions once finished.

All Vitessce packages will continue to be backwards compatible with previous view config schema versions.

### Exported constant values

Exported [constants](/docs/constants/) have been updated to reflect the changes to file types, data types, and coordination types as described here.

While no longer documented, we will continue to export the old constants for backwards compatibility (since their values will remain useful when  defining view configs corresponding to previous schema versions).
However, instead of implementing them using plain JS objects, deprecated constants will be exposed via [proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) which log deprecation messages to the console when accessed.

### VitessceConfig constructor

The [VitessceConfig](/docs/view-config-js/) constructor now requires `schemaVersion` as its first parameter.

This will help us to understand which schema version the config was constructed against, enabling better warning messages and error handling.
For instance, the API may show warnings or throw errors when passed invalid constants based on the specified view config schema version. New coordination types like `obsType` would be invalid when using an older schema version such as `1.0.7`.
We intend to update the constructors in R and Python to enforce this requirement as well.

This is a breaking change, but it should be straightforward to update existing code (`"1.0.7"` was the schema version that was previously hard-coded in `vitessce` v1.1.21).

```diff
- const vc = new VitessceConfig("My config");
+ const vc = new VitessceConfig("1.0.7", "My config"); // Previous behavior
```

For new code, we recommend using the latest view config schema version:

```js
const vc = new VitessceConfig("1.0.13", "My config");
```

For a full list of valid `schemaVersion` values, see the table of [schema versions](/docs/view-config-json/#version).

## Next steps

While we have primarily been thinking of observations and features at the cellular scale, in theory an observation could instead represent an entity at a larger scale such as a tissue sample or donor.
We hope to enable this use case by supporting mappings between `obsType`s, for instance to indicate which cells belong to which samples, if a dataset contains multiple tissue sample observations with per-sample cellular observations.
Such mappings could also be performed in the opposite direction to capture which organelles belong to which cells.
