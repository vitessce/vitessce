import {
    Vector2,
    Vector3
} from "../../node_modules/three/build/three.module.js";

var VolumeShaderNew = {
    uniforms: {
        "u_size": {value: new Vector3(1, 1, 1)},
        "u_vol_scale": {value: new Vector3(1, 1, 1)},
        "u_window_size": {value: new Vector2(1, 1)},
        "u_renderstyle": {value: 0},
        "u_renderthreshold": {value: 0.0},
        "u_opacity": {value: 0.5},
        "dt_scale": {value: 0.5},
        "u_clim": {value: new Vector2(0.2, 0.8)},
        "u_clim2": {value: new Vector2(0.2, 0.8)},
        "u_clim3": {value: new Vector2(0.2, 0.8)},
        "u_clim4": {value: new Vector2(0.2, 0.8)},
        "u_clim5": {value: new Vector2(0.2, 0.8)},
        "u_clim6": {value: new Vector2(0.2, 0.8)},
        "u_data": {value: null},
        "u_geo_depth": {value: null},
        "u_geo_color": {value: null},
        "volumeTex": {value: null},
        "volumeTex2": {value: null},
        "volumeTex3": {value: null},
        "volumeTex4": {value: null},
        "volumeTex5": {value: null},
        "volumeTex6": {value: null},
        "u_color": {value: new Vector3(0, 0, 0)},
        "u_color2": {value: new Vector3(0, 0, 0)},
        "u_color3": {value: new Vector3(0, 0, 0)},
        "u_color4": {value: new Vector3(0, 0, 0)},
        "u_color5": {value: new Vector3(0, 0, 0)},
        "u_color6": {value: new Vector3(0, 0, 0)},
        "u_cmdata": {value: null},
        "near": {value: 0.1},
        "far": {value: 10000},
        "alphaScale": {value: 0},
        "volumeCount": {value: 0},
        "finalGamma": {value: 0},
        "boxSize": {value: new Vector3(1, 1, 1)},
        "useVolumeMirrorX": {value: false},
    },
    vertexShader: [
        "uniform vec3 u_vol_scale;",
        "varying vec3 worldSpaceCoords;",
        "",
        "void main() {",
        "    worldSpaceCoords = position + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]",
        "    gl_Position = projectionMatrix * modelViewMatrix * vec4( position * u_vol_scale, 1.0 );",
        "    return;",
        "}",
    ].join("\n"),
    fragmentShader: [
        "precision highp float;",
        "precision mediump sampler3D;",
        "uniform float u_renderthreshold;",
        "uniform float dt_scale;",
        "varying vec3 worldSpaceCoords;",
        "in vec3 rayDirUnnorm;",
        "in vec3 cameraCorrected;",
        "uniform sampler2D u_stop_geom;",
        "uniform sampler3D volumeTex;",
        "uniform sampler3D volumeTex2;",
        "uniform sampler3D volumeTex3;",
        "uniform sampler3D volumeTex4;",
        "uniform sampler3D volumeTex5;",
        "uniform sampler3D volumeTex6;",
        "uniform vec2 u_clim;",
        "uniform vec2 u_clim2;",
        "uniform vec2 u_clim3;",
        "uniform vec2 u_clim4;",
        "uniform vec2 u_clim5;",
        "uniform vec2 u_clim6;",
        "uniform sampler2D u_cmdata;",
        "uniform sampler2D u_geo_depth;",
        "uniform sampler2D u_geo_color;",
        "uniform vec3 u_color;",
        "uniform vec3 u_color2;",
        "uniform vec3 u_color3;",
        "uniform vec3 u_color4;",
        "uniform vec3 u_color5;",
        "uniform vec3 u_color6;",
        "uniform float alphaScale;",
        "uniform float finalGamma;",
        "uniform float volumeCount;",
        "uniform highp vec3 boxSize;",
        "uniform bool useVolumeMirrorX;",
        "uniform vec3 u_size;",
        "uniform int u_renderstyle;",
        "uniform float u_opacity;",
        "uniform vec2 u_window_size;",
        "vec4 apply_colormap(float val);",
        "void cast_dvr(vec3 start_loc, vec3 step, int nsteps);",
        "float sample1(vec3 texcoords);" +
        "const int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3",
        "",
        "float linear_to_srgb(float x) {",
        "   if (x <= 0.0031308f) {",
        "     return 12.92f * x;",
        "   }",
        "   return 1.055f * pow(x, 1.f / 2.4f) - 0.055f;",
        "}",
        "void main() {",
        "        vec3 startGeom = worldSpaceCoords;",
        "        float x = (gl_FragCoord.x) / (u_window_size.x);",
        "        float y = (gl_FragCoord.y) / (u_window_size.y);",
        "        vec2 coord = vec2(x, y);",
        "        vec3 stopGeom = texture2D(u_geo_color, coord).rgb;",
        "        vec3 ray = stopGeom.xyz - startGeom.xyz;",
        "        vec3 view_ray = normalize(stopGeom.xyz - startGeom.xyz);",
        "        vec3 start_loc = startGeom;",
        "        // stepvector",
        "        vec3 step = view_ray/u_size.x;",
        "        // Decide how many steps to take",
        "        int nsteps = int( (ray.r / step.r) + 0.5 );",
        //"        int nsteps = MAX_STEPS;",
        "        cast_dvr(start_loc, step, nsteps);",
        "        if (gl_FragColor.a < 0.05){",
        "                discard;",
        "         }",
        "         gl_FragColor.r = linear_to_srgb(gl_FragColor.r);",
        "         gl_FragColor.g = linear_to_srgb(gl_FragColor.g);",
        "         gl_FragColor.b = linear_to_srgb(gl_FragColor.b);",
        "}",
        "void cast_dvr(vec3 start_loc, vec3 step, int nsteps) {",
        "        vec3 loc = start_loc;",
        "        float total = 0.0;",
        "        vec3 rgbCombo = vec3(0.0);",
        "        for (int iter=0; iter<MAX_STEPS; iter++) {",
        "           if (iter >= nsteps)",
        "               break;",
        "           float val = texture(volumeTex, loc.xyz).r;",
        "           val = max(0.0, (val - u_clim[0]) / (u_clim[1] - u_clim[0]));",
        "           rgbCombo += max(0.0, min(1.0, val)) * u_color;",
        "           total += val;",
        "           if(volumeCount > 1.0){" +
        "               float val2 = texture(volumeTex2, loc.xyz).r;",
        "               val2 = max(0.0,(val2 - u_clim2[0]) / (u_clim2[1] - u_clim2[0]));",
        "               rgbCombo += max(0.0, min(1.0, val2)) * u_color2;",
        "               total += val2;",
        "           }",
        "           if(volumeCount > 2.0){" +
        "               float val3 = texture(volumeTex3, loc.xyz).r;",
        "               val3 = max(0.0,(val3 - u_clim3[0]) / (u_clim3[1] - u_clim3[0]));",
        "               rgbCombo += max(0.0, min(1.0, val3)) * u_color3;",
        "               total += val3;",
        "           }",
        "           if(volumeCount > 3.0){" +
        "               float val4 = texture(volumeTex4, loc.xyz).r;",
        "               val4 = max(0.0,(val4 - u_clim4[0]) / (u_clim4[1] - u_clim4[0]));",
        "               rgbCombo += max(0.0, min(1.0, val4)) * u_color4;",
        "               total += val4;",
        "           }",
        "           if(volumeCount > 4.0){" +
        "               float val5 = texture(volumeTex5, loc.xyz).r;",
        "               val5 = max(0.0,(val5 - u_clim5[0]) / (u_clim5[1] - u_clim5[0]));",
        "               rgbCombo += max(0.0, min(1.0, val5)) * u_color5;",
        "               total += val5;",
        "           }",
        "           if(volumeCount > 5.0){" +
        "               float val6 = texture(volumeTex6, loc.xyz).r;",
        "               val6 = max(0.0,(val6 - u_clim6[0]) / (u_clim6[1] - u_clim6[0]));",
        "               rgbCombo += max(0.0, min(1.0, val6)) * u_color6;",
        "               total += val6;",
        "           }",
        // "           total = min(total, 1.0);",
        // "           val_color = vec4(rgbCombo, total);",
        // "           val_color.a = val_color.a * dt_scale;",
        // "           gl_FragColor.rgb += (1.0 - gl_FragColor.a) * val_color.a * val_color.rgb;",
        // "           gl_FragColor.a += (1.0 - gl_FragColor.a) * val_color.a;",
        // "           if (gl_FragColor.a > 0.95)",
        // "               return;",
        "           total = min(total, 1.0);",
        "           vec4 val_color = vec4(rgbCombo, total);",
        "           val_color.a = (1.0 - pow(1.0 - val_color.a, 1.0)) * dt_scale;",
        "           gl_FragColor.rgb += (1.0 - gl_FragColor.a) * val_color.a * val_color.rgb;",
        "           gl_FragColor.a += (1.0 - gl_FragColor.a) * val_color.a;",
        "           if (gl_FragColor.a >= 0.95) {",
        "               break;",
        "           }",
        "           // Advance location deeper into the volume",
        "           loc += step;",
        "        }",
        "}",
    ].join("\n")
};

export {VolumeShaderNew};
