import {
    Vector2,
    Vector3
} from "../../node_modules/three/build/three.module.js";

var VolumeShaderNew = {
    uniforms: {
        "u_size": {value: new Vector3(1, 1, 1)},
        "u_vol_scale": {value: new Vector3(1, 1, 1)},
        "u_window_size": {value: new Vector2(1, 1)},
        "u_renderstyle": {value: 0},
        "u_renderthreshold": {value: 0.0},
        "u_opacity": {value: 0.5},
        "dt_scale": {value: 1.0},
        "u_clim": {value: new Vector2(0.2, 0.8)},
        "u_clim2": {value: new Vector2(0.2, 0.8)},
        "u_clim3": {value: new Vector2(0.2, 0.8)},
        "u_clim4": {value: new Vector2(0.2, 0.8)},
        "u_clim5": {value: new Vector2(0.2, 0.8)},
        "u_clim6": {value: new Vector2(0.2, 0.8)},
        "u_data": {value: null},
        "u_geo_depth": {value: null},
        "u_geo_color": {value: null},
        "volumeTex": {value: null},
        "volumeTex2": {value: null},
        "volumeTex3": {value: null},
        "volumeTex4": {value: null},
        "volumeTex5": {value: null},
        "volumeTex6": {value: null},
        "u_color": {value: new Vector3(0, 0, 0)},
        "u_color2": {value: new Vector3(0, 0, 0)},
        "u_color3": {value: new Vector3(0, 0, 0)},
        "u_color4": {value: new Vector3(0, 0, 0)},
        "u_color5": {value: new Vector3(0, 0, 0)},
        "u_color6": {value: new Vector3(0, 0, 0)},
        "u_cmdata": {value: null},
        "near": {value: 0.1},
        "far": {value: 10000},
        "alphaScale": {value: 0},
        "volumeCount": {value: 0},
        "finalGamma": {value: 0},
        "boxSize": {value: new Vector3(1, 1, 1)},
        "useVolumeMirrorX": {value: false},
    },
    vertexShader: [
        "uniform vec3 u_vol_scale;",
        "varying vec3 worldSpaceCoords;",
        "",
        "void main() {",
        "    worldSpaceCoords = position + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]",
        "    gl_Position = projectionMatrix * modelViewMatrix * vec4( position * u_vol_scale, 1.0 );",
        "    return;",
        "}",
    ].join("\n"),
    fragmentShader: [
        "precision highp float;",
        "precision mediump sampler3D;",
        "uniform float u_renderthreshold;",
        "uniform float dt_scale;",
        "varying vec3 worldSpaceCoords;",
        "in vec3 rayDirUnnorm;",
        "in vec3 cameraCorrected;",
        "uniform sampler2D u_stop_geom;",
        "uniform sampler3D volumeTex;",
        "uniform sampler3D volumeTex2;",
        "uniform sampler3D volumeTex3;",
        "uniform sampler3D volumeTex4;",
        "uniform sampler3D volumeTex5;",
        "uniform sampler3D volumeTex6;",
        "uniform vec2 u_clim;",
        "uniform vec2 u_clim2;",
        "uniform vec2 u_clim3;",
        "uniform vec2 u_clim4;",
        "uniform vec2 u_clim5;",
        "uniform vec2 u_clim6;",
        "uniform sampler2D u_cmdata;",
        "uniform sampler2D u_geo_depth;",
        "uniform sampler2D u_geo_color;",
        "uniform vec3 u_color;",
        "uniform vec3 u_color2;",
        "uniform vec3 u_color3;",
        "uniform vec3 u_color4;",
        "uniform vec3 u_color5;",
        "uniform vec3 u_color6;",
        "uniform float alphaScale;",
        "uniform float dtScale;",
        "uniform float finalGamma;",
        "uniform float volumeCount;",
        "uniform highp vec3 boxSize;",
        "uniform bool useVolumeMirrorX;",
        "uniform vec3 u_size;",
        "uniform int u_renderstyle;",
        "uniform float u_opacity;",
        "uniform vec2 u_window_size;",
        "vec4 apply_colormap(float val);",
        "void cast_dvr(vec3 start_loc, vec3 step, int nsteps);",
        "float sample1(vec3 texcoords);" +
        "const int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3",
        "",
        "float linear_to_srgb(float x) {",
        "   if (x <= 0.0031308f) {",
        "     return 12.92f * x;",
        "   }",
        "   return 1.055f * pow(x, 1.f / 2.4f) - 0.055f;",
        "}",
        "void main() {",
        "        vec3 startGeom = worldSpaceCoords;",
        "        float x = (gl_FragCoord.x) / (u_window_size.x);",
        "        float y = (gl_FragCoord.y) / (u_window_size.y);",
        "        vec2 coord = vec2(x, y);",
        "        vec3 stopGeom = texture2D(u_geo_color, coord).rgb;",
        "        vec3 ray = stopGeom.xyz - startGeom.xyz;",
        "        vec3 view_ray = normalize(stopGeom.xyz - startGeom.xyz);",
        "        vec3 start_loc = startGeom;",
        "        // stepvector",
        "        vec3 step = view_ray/u_size.x;",
        "        // Decide how many steps to take",
        "        int nsteps = int( (ray.r / step.r) + 0.5 );",
        //"        int nsteps = MAX_STEPS;",
        "        cast_dvr(start_loc, step, nsteps);",
        "        if (gl_FragColor.a < 0.05){",
        "                discard;",
        "         }",
        "         gl_FragColor.r = linear_to_srgb(gl_FragColor.r);",
        "         gl_FragColor.g = linear_to_srgb(gl_FragColor.g);",
        "         gl_FragColor.b = linear_to_srgb(gl_FragColor.b);",
        "}",
        "float sample1(vec3 texcoords) {",
        "        /* Sample float value from a 3D texture. Assumes intensity data. */",
        "        return texture(volumeTex, texcoords.xyz).r;",
        "}",
        "vec4 apply_colormap(float val) {",
        "        float diff = (u_clim[1] - u_clim[0]);",
        "        if ( diff <= 0.0 ){",
        "            diff = 0.01;",
        "        }",
        "        val = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);",
        "        if ( val >= 1.0 ){",
        "            val = 1.0;",
        "        }",
        "        vec4 color = vec4(u_color*val, val);",
        "        return color;",
        "}",
        "void cast_dvr(vec3 start_loc, vec3 step, int nsteps) {",
        "        gl_FragColor = vec4(0.0); // init transparent",
        "        vec4 color3 = vec4(0.0); // final color",
        "        vec3 loc = start_loc;",
        "        for (int iter=0; iter<MAX_STEPS; iter++) {",
        "                if (iter >= nsteps)",
        "                   break;",
        "                vec4 val_color = vec4(0.0, 0, 0, 0);",
        "                float val = sample1(loc);",
        "                if (val > u_renderthreshold) {",
        "                        vec4 val_color = apply_colormap(val);",
        //"                        vec4 val_color = vec4(val,val,val,val);",
        "                        val_color.a = val_color.a * dt_scale;",
        "                        gl_FragColor.rgb += (1.0 - gl_FragColor.a) * val_color.a * val_color.rgb;",
        "                        gl_FragColor.a += (1.0 - gl_FragColor.a) * val_color.a;",
        "                }",
        "                //gl_FragColor = apply_colormap(val);",
        "                if (gl_FragColor.a > 0.95) {",
        "                        return;",
        "                }",
        "                // Advance location deeper into the volume",
        "                loc += step;",
        "        }",
        "}",
    ].join("\n")
};

export {VolumeShaderNew};
